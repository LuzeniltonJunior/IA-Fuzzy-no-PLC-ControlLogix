//	PROJETO:	IA FUZZY PARA AJUSTE EM TEMPO REAL DE GANHOS DO CONTROLADOR PID EM SISTEMAS INSTAVEIS
//	AUTOR:		ENG. LUZENILTON TORRES
//	DATA:		24/09/2024



////////////////////////////////////////////////////////////////////////////////////////
//			FILTRAGEM DAS VARIAVES DE ENTRADA	
////////////////////////////////////////////////////////////////////////////////////////



//TIMER DE FILTRAGEM
TONR(FILTRAGEM);
TIME_FILTRAGEM			:= T_LOOP_SISTEMA*2;
FILTRAGEM.PRE 			:= TIME_FILTRAGEM;
FILTRAGEM.ENABLEIN 		:= 1;
FILTRAGEM.RESET 		:= 0;
FILTRAGEM.TIMERENABLE	:= 1;


//DISPARO DO TIMER
IF FILTRAGEM.DN THEN
	
	//RESETA O TIMER
	FILTRAGEM.RESET := 1;
	
	//SALVA O ERRO ABSOLUTO ATUAL
	ERROS[POSICAO]:= ABS(ERRO);

	//SALVA A DERIVADA ABSOLUTA ATUAL
	DERIVADAS[POSICAO] := ABS((ERROS[POSICAO] - ERRO_ANTERIOR)/TIME_FILTRAGEM);

	//SALVA O ULTIMO ERRO
	ERRO_ANTERIOR := ERROS[POSICAO];

	//NAO DEIXA TIRAR A MEDIA PONDERADA ENQUANTO O BUFFER NAO ESTA COMPLETAMENTE CHEIO
	IF NOT(PRIMEIRA_EXECUCAO) THEN
	
		//ERRO DE ENTRADA DO FUZZIFICADOR
		ERRO_FILTRADO := (ERROS[(POSICAO) MOD 5]*5 + ERROS[(POSICAO+1) MOD 5]*4 + ERROS[(POSICAO+2) MOD 5]*3 
					+ ERROS[(POSICAO+3) MOD 5]*2 + ERROS[(POSICAO+4) MOD 5])/15;

		//DERIVADA DE ENTRADA DO FUZZIFICADOR
		DERIVADA_FILTRADA := (DERIVADAS[(POSICAO) MOD 5]*5 + DERIVADAS[(POSICAO+1) MOD 5]*4 + DERIVADAS[(POSICAO+2) MOD 5]*3 
					+ DERIVADAS[(POSICAO+3) MOD 5]*2 + DERIVADAS[(POSICAO+4) MOD 5])/15;
	ELSE
		
		//CONTA A QUANTIDADE DE POSICOES CHEIAS NO BUFFER
		EXECUCAO := EXECUCAO + 1;
		
		//SE ENCHEU FLIPA O BIT QUE DEIXA TIRAR A MEDIA
		IF EXECUCAO > 4 THEN
			EXECUCAO 		 	:= 0;
			PRIMEIRA_EXECUCAO 	:= 0;
		END_IF;

	END_IF;


	//INCREMENTA O BUFFER CIRCULAR
	POSICAO := (POSICAO + 1) MOD 5;

END_IF;




////////////////////////////////////////////////////////////////////////////////////////
//		DEFININDO OS REFERENCIAIS DE ERRO

ERRO_BAIXO := 0.001*SP;	
ERRO_MEDIO := 0.05*SP;	
ERRO_ALTO  := 0.15*SP;	


////////////////////////////////////////////////////////////////////////////////////////
//		ANALIZANDO AS ESTATISTICAS DAS ULTIMAS 200 VARIACOES DO ERRO (DERIVADA)


//TIMER DE AMOSTRAGEM
TONR(AMOSTRAGEM);
TEMPO_AMOSTRAGEM		:= T_LOOP_SISTEMA*2;	
AMOSTRAGEM.PRE 			:= TEMPO_AMOSTRAGEM;
AMOSTRAGEM.ENABLEIN 	:= 1;
AMOSTRAGEM.TIMERENABLE 	:= 1;
AMOSTRAGEM.RESET 		:= 0;

IF AMOSTRAGEM.DN THEN
	
	AMOSTRAGEM.RESET 		:= 1;
	AMOSTRAGEM.TIMERENABLE 	:= 0;

	//SE AUMENTAR MUITO ATRASA A RESPOSTA
	TAMANHO_BUFFER := 200;

	//LIGA O BUFFER CIRCULAR
	IF BUFFER_CIRCULAR THEN

		//RETIRA O ULTIMO VALOR DO VETOR DE DERIVADAS
		ACC_DERIVADA := ACC_DERIVADA - VETOR_DERIVADAS[CONTAGEM];

		//RETIRA O ULTIMO VALOR DO VETOR DE DESVIOS
		ACC_DESVIOS_QUADRADO := ACC_DESVIOS_QUADRADO - VETOR_DESVIOS[CONTAGEM];

	END_IF;
	
	//ACUMULA OS K-ULTIMOS VALORES
	ACC_DERIVADA:= ACC_DERIVADA + DERIVADA_FILTRADA;
	ACC_DESVIOS_QUADRADO := ACC_DESVIOS_QUADRADO + DESVIO*DESVIO;	
	
	//SALVA A ULTIMA DERIVADA NO VETOR
	VETOR_DERIVADAS[CONTAGEM] :=  DERIVADA_FILTRADA;

	//SALVA O ULTIMO DESVIO NO VETOR
	VETOR_DESVIOS[CONTAGEM] :=  DESVIO*DESVIO;
	
	//INCREMENTA A CONTAGEM DE DERIVADAS
	CONTAGEM := CONTAGEM + 1;
	
	//SE A JANELA ENCHEU, LIGA O BUFFER CIRCULAR E VOLTA AO SEU INICIO
	IF CONTAGEM > TAMANHO_BUFFER-1 THEN
		BUFFER_CIRCULAR :=1;
		CONTAGEM := 0;		
	END_IF;

////////////////////////////////////////////////////////////////////////////////////////
//		DEFININDO OS REFERENCIAIS DA DERIVADA DO ERRO

	//DERIVADA MEDIA (VARIAVEL DE REFERENCIA)
	DERIVADA_MEDIA := ACC_DERIVADA/TAMANHO_BUFFER;

	//DESVIO
	DESVIO := DERIVADA_FILTRADA - DERIVADA_MEDIA;

	//VARIANCIA COM UM GRAU DE LIBERDADE
	VARIANCIA := ACC_DESVIOS_QUADRADO/(TAMANHO_BUFFER-1);

	//DESVIO PADRAO
	DESVIO_PADRAO := SQRT(VARIANCIA);
	
	//VARIAVEIS DE REFERENCIA RESTANTES	
	DERIVADA_BAIXA := DERIVADA_MEDIA - DESVIO_PADRAO;
	IF DERIVADA_BAIXA < 0 THEN
		DERIVADA_BAIXA := 0;
	END_IF;
	DERIVADA_ALTA  := DERIVADA_MEDIA + DESVIO_PADRAO;

END_IF;


////////////////////////////////////////////////////////////////////////////////////////
//							CONTROLE DO ALGORITMO FUZZY		
////////////////////////////////////////////////////////////////////////////////////////

//TEMPO DE LOOP_FUZZY EM MILISSEGUNDOS
//FUZZY_TIME := (TEMPO_AMOSTRAGEM*TAMANHO_BUFFER)/4;
FUZZY_TIME := TEMPO_AMOSTRAGEM*2;

//LIGA FUZZY
IF FUZZY_ON THEN

	//TIMER DE LOOP FUZZY
	TONR(FUZZY_LOOP);
	FUZZY_LOOP.PRE 			:= FUZZY_TIME;
	FUZZY_LOOP.ENABLEIN 	:= 1;
	FUZZY_LOOP.TIMERENABLE 	:= 1;
	FUZZY_LOOP.RESET 		:= 0;	

ELSE
	//RESET DO TEMPORIZADOR
	FUZZY_LOOP.ENABLEIN 	:= 0;
	FUZZY_LOOP.TIMERENABLE 	:= 0;
	FUZZY_LOOP.RESET 		:= 1;
	FUZZY_LOOP.DN			:= 0;

	//RESET DAS VARIAVEIS DA MEDIA MOVEL
	BUFFER_CIRCULAR			:= 0;
	ACC_DERIVADA			:= 0;
	ACC_DESVIOS_QUADRADO	:= 0;
	CONTAGEM				:= 0;
	

	//DESLIGA A AMOSTRAGEM ESTATISTICA
	T_AMOSTRAGEM.TIMERENABLE 	:= 0;
	T_AMOSTRAGEM.RESET 			:= 1;

	//RETORNA AS VARIAVEIS SINTONIZADAS MANUALMENTE
	KP := KP_MANUAL;
	TI := TI_MANUAL;
	TD := TD_MANUAL;

	//RESET DA FILTRAGEM
	POSICAO				:= 0;
	ERRO_FILTRADO		:= 0;
	DERIVADA_FILTRADA	:= 0;
	PRIMEIRA_EXECUCAO 	:= 1;
	EXECUCAO 		 	:= 0;


END_IF;
	


////////////////////////////////////////////////////////////////////////////////////////
//							INICIO DO ALGORITMO FUZZY		
////////////////////////////////////////////////////////////////////////////////////////

//TESTA SE O TIMER DE LOOP DISPAROU
IF FUZZY_LOOP.DN THEN;
	

///////////////////////////////////////////////////////////////////////////////	
//			CALCULO DO VETOR DE PERTINENCIA DO ERRO

	//CERTEZA DE QUE O ERRO EH BAIXO
	IF ERRO_FILTRADO <= ERRO_BAIXO THEN
		PERTI_ERRO[0] := 1;	//ERRO BAIXO
		PERTI_ERRO[1] := 0;	//ERRO MEDIO
		PERTI_ERRO[2] := 0;	//ERRO ALTO
	ELSE
		
		//CERTEZA DE QUE O ERRO EH ALTO
		IF ERRO_FILTRADO >= ERRO_ALTO THEN
			PERTI_ERRO[0] := 0;	//ERRO BAIXO
			PERTI_ERRO[1] := 0;	//ERRO MEDIO
			PERTI_ERRO[2] := 1;	//ERRO ALTO
		ELSE

			//MEIO TERMO
			IF ERRO_FILTRADO < ERRO_MEDIO THEN
				
				//SO PRA GARANTIR QUE NAO VAI DAR ERRO DE DIVISAO POR ZERO
				IF ERRO_MEDIO <> ERRO_BAIXO THEN

					//VAMOS CALCULAR PRIMEIRO O ERRO MEDIO
					PERTI_ERRO[1] := (ERRO_FILTRADO-ERRO_BAIXO)/(ERRO_MEDIO-ERRO_BAIXO);

				END_IF;
				
				//ERRO BAIXO	
				PERTI_ERRO[0] := 1 - PERTI_ERRO[1];
				
				//ERRO ALTO		
				PERTI_ERRO[2] := 0;	
			
			ELSE
				
				//SO PRA GARANTIR QUE NAO VAI DAR ERRO DE DIVISAO POR ZERO
				IF ERRO_MEDIO <> ERRO_ALTO THEN 

					//VAMOS CALCULAR PRIMEIRO O ERRO ALTO
					PERTI_ERRO[2] := (ERRO_FILTRADO- ERRO_MEDIO)/(ERRO_ALTO-ERRO_MEDIO);

				END_IF;
				
				//PERTINENCIA DO ERRO MEDIO	
				PERTI_ERRO[1] := 1 - PERTI_ERRO[2];
				
				//PERTINENCIA DO ERRO BAIXO	
				PERTI_ERRO[0] := 0;
				
			END_IF;	//FIM IF MEIO TERMO				
		END_IF; //FIM IF ALTO
	END_IF; //FIM IF BAIXO

	
	
///////////////////////////////////////////////////////////
//		CALCULO DO VETOR DE PERTINENCIA DA DERIVADA

	//CERTEZA DE QUE A DERIVADA EH BAIXA
	IF DERIVADA_FILTRADA <= DERIVADA_BAIXA THEN
		PERTI_DERIVADA[0] := 1;	//DERIVADA BAIXA
		PERTI_DERIVADA[1] := 0;	//DERIVADA MEDIA
		PERTI_DERIVADA[2] := 0;	//DERIVADA ALTA
	ELSE
		
		//CERTEZA DE QUE A DERIVADA EH ALTA
		IF DERIVADA_FILTRADA >= DERIVADA_ALTA THEN
			PERTI_DERIVADA[0] := 0;	//DERIVADA BAIXA
			PERTI_DERIVADA[1] := 0;	//DERIVADA MEDIA
			PERTI_DERIVADA[2] := 1;	//DERIVADA ALTA
		ELSE

			//MEIO TERMO
			IF DERIVADA_FILTRADA < DERIVADA_MEDIA THEN
				
				//SO PRA GARANTIR QUE NAO VAI DAR ERRO DE DIVISAO POR ZERO
				IF DERIVADA_MEDIA <> DERIVADA_BAIXA THEN

					//VAMOS CALCULAR PRIMEIRO A PERTINENCIA DA DERIVADA MEDIA
					PERTI_DERIVADA[1] := (DERIVADA_FILTRADA-DERIVADA_BAIXA)/(DERIVADA_MEDIA-DERIVADA_BAIXA);

				END_IF;
				
				//PERTINENCIA DA DERIVADA BAIXA	
				PERTI_DERIVADA[0] := 1 - PERTI_DERIVADA[1];
				
				//PERTINENCIA DA DERIVADA ALTA		
				PERTI_DERIVADA[2] := 0;	
			
			ELSE
				
				//SO PRA GARANTIR QUE NAO VAI DAR ERRO DE DIVISAO POR ZERO
				IF DERIVADA_MEDIA <> DERIVADA_ALTA THEN 

					//VAMOS CALCULAR PRIMEIRO A DERIVADA ALTA
					PERTI_DERIVADA[2] := (DERIVADA_FILTRADA-DERIVADA_MEDIA)/(DERIVADA_ALTA-DERIVADA_MEDIA);

				END_IF;
				
				//PERTINENCIA DA DERIVADA MEDIA
				PERTI_DERIVADA[1] := 1 - PERTI_DERIVADA[2];
				
				//PERTINENCIA DA DERIVADA BAIXA
				PERTI_DERIVADA[0] := 0;
				
			END_IF;	//FIM IF MEIO TERMO				
		END_IF; //FIM IF ALTA
	END_IF; //FIM IF BAIXA



///////////////////////////////////////////////////////////////////////////////
//					CALCULANDO AS INFERENCIAS FUZZY
//   	(AQUI EH ONDE A MAQUINA APRENDE O PENSAMENTO DO PROGRAMADOR)
///////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//							INFERENCIAS DO KP

	//	SE O ERRO EH BAIXO ENTAO DIMINUI O KP...
	//	=> EVITA OSCILACOES
	FUZZ_KP[0] := PERTI_ERRO[0];
	
	
	//	SE O ERRO EH BAIXO E A TI EH ALTA ENTAO DIMINUI O KP...
	//	=> DEIXA O TRABALHO PRO TI
	FUZZ_KP[0] := PERTI_ERRO[0];

	IF FUZZ_TI[2] < FUZZ_KP[0] THEN
		FUZZ_KP[0] := FUZZ_TI[2];
	END_IF;


	//	SE O ERRO EH MEDIO ENTAO O KP EH MEDIO...
	//	=> CORRECAO MODERADA
	FUZZ_KP[1] := PERTI_ERRO[1];


	//	SE O ERRO EH MEDIO E O TI EH BAIXO E A DERIVADA EH BAIXA ENTAO O KP EH MEDIO...
	//	=> CORRECAO MODERADA
	FUZZ_KP[1] := PERTI_ERRO[1];

	IF FUZZ_TI[0] < FUZZ_KP[1] THEN
		FUZZ_KP[1] := FUZZ_TI[0];
	END_IF;


	//	SE O ERRO EH ALTO ENTAO AUMENTA O KP...
	//	=> CORRECAO RAPIDA SEM AUMENTAR AS OSCILACOES E EVITANDO OVERSHOOTING
	FUZZ_KP[2] := PERTI_ERRO[2];



//////////////////////////////////////////////////////////////////////////////
//							INFERENCIAS DO TI

	//	SE O ERRO EH ALTO ENTAO DIMINUI O TI...
	//	=> ACUMULACAO RAPIDA PARA CORRECAO RAPIDA
	FUZZ_TI[0] := PERTI_ERRO[2]; 

	//	SE (O ERRO EH BAIXO OU MEDIO) E O KP EH BAIXO ENTAO DIMUNUI O TI...
	//	=> ACUMULACAO LENTA PARA EVITAR OVERSHOOTING
	FUZZ_TI[0] := PERTI_ERRO[0];
	IF FUZZ_TI[0] < PERTI_ERRO[1] THEN
		FUZZ_TI[0] := PERTI_ERRO[1];
	END_IF;
	IF FUZZ_TI[0] < FUZZ_KP[0] THEN
		FUZZ_TI[0] := FUZZ_KP[0];
	END_IF;

	
	//	SE O ERRO EH MEDIO ENTAO O TI EH MEDIO...
	//	=> CORRECAO SUAVE E ESTAVEL
	FUZZ_TI[1] := PERTI_ERRO[1];


	//	SE O ERRO EH BAIXO E A DERIVADA EH ALTA ENTAO AUMENTA O TI...
	//	=> ACUMULACAO LENTA PARA EVITAR OVERSHOOTING
	FUZZ_TI[2] := PERTI_ERRO[0];
	IF FUZZ_TI[2] < PERTI_DERIVADA[2] THEN
		FUZZ_TI[2] := PERTI_DERIVADA[2];
	END_IF;



//////////////////////////////////////////////////////////////////////////////
//							INFERENCIAS DO TD

	//	SE O ERRO EH ALTO ENTAO DIMINUI O TD...
	//	=> DERIVATIVO MINIMO PARA EVITAR AMORTECER A CORRECAO RAPIDA
	FUZZ_TD[0] := PERTI_ERRO[2];
	
	//	SE A DERIVADA EH BAIXA ENTAO DIMINUI O TD...
	//	=> DIMINUI O AMORTECIMENTO PARA O TI RECUPERAR O ERRO MINIMO
	FUZZ_TD[0] := PERTI_DERIVADA[0];
	

	//	SE DERIVADA EH MEDIA ENTAO O TD EH MEDIO...
	//	=> AMORTECIMENTO MODERADO
	FUZZ_TD[1] := PERTI_DERIVADA[1];

	
	//	SE A DERIVADA EH ALTA ENTAO AUMENTA O TD...
	//	=> FORTE AMORTECIMENTO PARA PEQUENAS VARIACOES
	FUZZ_TD[2] := PERTI_DERIVADA[2];



///////////////////////////////////////////////////////////////////////////////
//					DEFUZZYFICACAO DAS INFERENCIAS
//   			(AQUI EH ONDE A MAQUINA TOMA UMA DECISAO)
///////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//						VARIAVEIS DE DEFUZIFICACAO

	KP_BAIXO 	:= KP_MIN;
	KP_MEDIO 	:= (KP_MIN + KP_MAX)/2;
	KP_ALTO		:= KP_MAX;

	TI_BAIXO 	:= TI_MIN;
	TI_MEDIO 	:= (TI_MIN + TI_MAX)/2;
	TI_ALTO		:= TI_MAX;

	TD_BAIXO 	:= TD_MIN;
	TD_MEDIO 	:= (TD_MIN + TD_MAX)/2;
	TD_ALTO		:= TD_MAX;


//////////////////////////////////////////////////////////////////////////////
//							CALCULO DAS SAIDAS
//	(COMBINACAO LINEAR DOS VETORES DE INFERENCA E AS VARIAVEIS FUZZY)

	//KP RESULTANTE
	KP := FUZZ_KP[0]*KP_BAIXO +	FUZZ_KP[1]*KP_MEDIO + FUZZ_KP[2]*KP_ALTO;

	IF KP < KP_BAIXO THEN
		KP := KP_BAIXO;
	END_IF;
	IF KP > KP_ALTO THEN
		KP := KP_ALTO;
	END_IF;

	//TI RESULTANTE
	TI := FUZZ_TI[0]*TI_BAIXO +	FUZZ_TI[1]*TI_MEDIO + FUZZ_TI[2]*TI_ALTO;

	IF TI < TI_BAIXO THEN
		TI := TI_BAIXO;
	END_IF;
	IF TI > TI_ALTO THEN
		TI := TI_ALTO;
	END_IF;

	//TD RESULTANTE
	TD := FUZZ_TD[0]*TD_BAIXO +	FUZZ_TD[1]*TD_MEDIO + FUZZ_TD[2]*TD_ALTO;

	IF TD < TD_BAIXO THEN
		TD := TD_BAIXO;
	END_IF;
	IF TD > TD_ALTO THEN
		TD := TD_ALTO;
	END_IF;


//////////////////////////////////////////////////////////////////////////////
//									FIM!

	//REINICIA O TIMER
	FUZZY_LOOP.RESET := 1;

END_IF;










